<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Myanmar Agro-Advisories</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: #f0f2f5;
      padding: 20px;
      color: #333;
    }
    h1 {
        color: #1a73e8; /* Google Blue */
        text-align: center;
        margin-bottom: 30px;
    }
    #search-input {
        width: calc(100% - 22px); /* Account for padding */
        padding: 10px;
        margin-bottom: 20px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 1em;
    }
    .card {
      background: #fff;
      margin-bottom: 15px;
      padding: 15px 20px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
      transition: all 0.3s cubic-bezier(.25,.8,.25,1);
    }
    .card:hover {
        box-shadow: 0 5px 10px rgba(0,0,0,0.20), 0 3px 3px rgba(0,0,0,0.15);
    }
    summary {
      font-size: 1.2em;
      font-weight: 600;
      cursor: pointer;
      color: #1a73e8;
    }
    details[open] summary {
        margin-bottom: 10px;
    }
    ul {
      margin: 0;
      padding-left: 25px;
      list-style: disc;
      line-height: 1.6;
    }
    li {
        margin-bottom: 5px;
    }
    .no-results {
        text-align: center;
        color: #777;
        font-style: italic;
        margin-top: 20px;
    }
    #suggestions-list {
        border: 1px solid #ccc;
        border-top: none;
        max-height: 150px;
        overflow-y: auto;
        background-color: #fff;
        position: absolute;
        width: calc(100% - 42px); /* Match search input width */
        z-index: 1000;
        border-radius: 0 0 4px 4px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .suggestion-item {
        padding: 8px 10px;
        cursor: pointer;
    }
    .suggestion-item:hover {
        background-color: #f0f0f0;
    }
  </style>
</head>
<body>
  <h1>Myanmar Agricultural Pest & Disease Advisories</h1>
  <div style="position: relative;">
    <input type="text" id="search-input" placeholder="Search articles by title or content..." autocomplete="off">
    <div id="suggestions-list"></div>
  </div>
  <div id="container">Loading articles...</div>

  <script>
    const container = document.getElementById("container");
    const searchInput = document.getElementById("search-input");
    const suggestionsList = document.getElementById("suggestions-list");
    let allArticlesData = []; // Store all loaded article data
    let debounceTimer;

    async function loadArticle(index) {
      try {
        const response = await fetch(`data/article${index}.json`);
        if (!response.ok) {
            console.warn(`Failed to load article${index}.json: ${response.statusText}`);
            return null; // Indicate failure
        }
        const data = await response.json();
        // Add the index to the data for reference if needed later
        data.id = index;
        return data;
      } catch (err) {
          console.error(`Error fetching or parsing article${index}.json`, err);
          return null; // Indicate failure
      }
    }

    function renderArticles(articlesToRender) {
        container.innerHTML = ""; // Clear previous content
        if (articlesToRender.length === 0) {
            container.innerHTML = '<p class="no-results">No articles match your search.</p>';
            return;
        }

        articlesToRender.forEach(data => {
            if (!data) return; // Skip if data is null (failed load)

            const card = document.createElement("div");
            card.className = "card";

            // Use a more robust way to get title and content
            const title = data.entries && data.entries[0] && data.entries[0].title ? data.entries[0].title : (data.original_title || `Article ${data.id}`);
            let bullets = [];
            if (data.entries && Array.isArray(data.entries)) {
                data.entries.forEach(entry => {
                    if (entry.content && Array.isArray(entry.content)) {
                        bullets = bullets.concat(entry.content);
                    }
                });
            }

            card.innerHTML = `
                <details>
                <summary>${title}</summary>
                <ul>
                    ${bullets.map(item => `<li>${item}</li>`).join("")}
                </ul>
                </details>
            `;
            // Ensure details are closed by default if needed, or manage state
            // const detailsElement = card.querySelector('details');
            // detailsElement.removeAttribute('open');
            container.appendChild(card);
        });
    }

    function updateSuggestions(searchTerm) {
        suggestionsList.innerHTML = ''; // Clear previous suggestions
        if (!searchTerm) {
            suggestionsList.style.display = 'none';
            return;
        }

        const lowerSearchTerm = searchTerm.toLowerCase();
        const matchingTitles = allArticlesData
            .map(data => {
                if (!data || !data.entries || !Array.isArray(data.entries)) return null;
                // Find the first title in the entries, default if none
                const firstEntry = data.entries[0];
                const title = firstEntry && firstEntry.title ? firstEntry.title : `Article ${data.id}`;
                return { title: title, data: data }; // Return object with title and original data
            })
            .filter(item => item && item.title.toLowerCase().includes(lowerSearchTerm))
            .slice(0, 10); // Limit suggestions

        if (matchingTitles.length > 0) {
            matchingTitles.forEach(item => {
                const div = document.createElement('div');
                div.textContent = item.title;
                div.className = 'suggestion-item';
                div.onclick = () => {
                    searchInput.value = item.title; // Set input to clicked suggestion
                    suggestionsList.innerHTML = ''; // Clear suggestions
                    suggestionsList.style.display = 'none';
                    filterArticles(); // Trigger search with the selected title
                };
                suggestionsList.appendChild(div);
            });
            suggestionsList.style.display = 'block';
        } else {
            suggestionsList.style.display = 'none';
        }
    }

    function filterArticles() {
        // suggestionsList.innerHTML = ''; // Clear suggestions when performing full search
        // suggestionsList.style.display = 'none';
        const searchTerm = searchInput.value.toLowerCase().trim();

        // If search term is empty after clearing suggestions or initially, show all
        if (!searchTerm) {
            renderArticles(allArticlesData);
            return;
        }

        const filteredArticles = allArticlesData.filter(data => {
            if (!data || !data.entries || !Array.isArray(data.entries)) return false;

            // Check if the search term matches any title or content within the article's entries
            return data.entries.some(entry => {
                const titleMatch = entry.title && entry.title.toLowerCase().includes(searchTerm);
                const contentMatch = entry.content && Array.isArray(entry.content) &&
                                   entry.content.join(" ").toLowerCase().includes(searchTerm);
                return titleMatch || contentMatch;
            });
        });

        renderArticles(filteredArticles);
    }

    async function loadAllArticles() {
      const articleCount = 43; // Assuming 43 articles based on previous context
      container.innerHTML = "Loading articles...";
      allArticlesData = []; // Reset data
      const promises = [];

      for (let i = 1; i <= articleCount; i++) {
        promises.push(loadArticle(i));
      }

      // Wait for all fetch requests to complete
      const results = await Promise.all(promises);
      allArticlesData = results.filter(data => data !== null); // Filter out failed loads

      renderArticles(allArticlesData); // Initial render of all articles

      // Add event listener for search input after data is loaded
      searchInput.addEventListener('input', () => {
          clearTimeout(debounceTimer);
          const currentSearchTerm = searchInput.value;
          // Update suggestions immediately
          updateSuggestions(currentSearchTerm);
          // Debounce the full article filtering
          debounceTimer = setTimeout(() => {
              filterArticles();
          }, 300); // Adjust debounce time as needed
      });

      // Hide suggestions when clicking outside
      document.addEventListener('click', (event) => {
          if (!searchInput.contains(event.target) && !suggestionsList.contains(event.target)) {
              suggestionsList.style.display = 'none';
          }
      });
    }

    loadAllArticles();
  </script>
</body>
</html>
